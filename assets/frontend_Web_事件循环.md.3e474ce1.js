import{_ as t,o as e,c as a,a as i}from"./app.a2747a60.js";const _=JSON.parse('{"title":"事件循环 EventLoop","description":"","frontmatter":{},"headers":[{"level":2,"title":"同步任务和异步任务","slug":"同步任务和异步任务","link":"#同步任务和异步任务","children":[]},{"level":2,"title":"宏任务 macro task","slug":"宏任务-macro-task","link":"#宏任务-macro-task","children":[]},{"level":2,"title":"微任务 micro task","slug":"微任务-micro-task","link":"#微任务-micro-task","children":[]},{"level":2,"title":"执行流程","slug":"执行流程","link":"#执行流程","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"relativePath":"frontend/Web/事件循环.md"}'),r={name:"frontend/Web/事件循环.md"},l=i('<h1 id="事件循环-eventloop" tabindex="-1">事件循环 EventLoop <a class="header-anchor" href="#事件循环-eventloop" aria-hidden="true">#</a></h1><p>Event Loop 即事件循环，是浏览器(或 Node)防止 js 单线程 运行时阻塞的一种机制，也就是我们经常使用异步的原理</p><h2 id="同步任务和异步任务" tabindex="-1">同步任务和异步任务 <a class="header-anchor" href="#同步任务和异步任务" aria-hidden="true">#</a></h2><p>同步任务： 同步任务会在调用栈中按照顺序等待主线程依次执行<br><br> 异步任务： 异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。</p><h2 id="宏任务-macro-task" tabindex="-1">宏任务 macro task <a class="header-anchor" href="#宏任务-macro-task" aria-hidden="true">#</a></h2><table><thead><tr><th>-</th><th style="text-align:center;">浏览器</th><th style="text-align:right;">Node</th></tr></thead><tbody><tr><td>I/O</td><td style="text-align:center;">✅</td><td style="text-align:right;">✅</td></tr><tr><td>setTimeout</td><td style="text-align:center;">✅</td><td style="text-align:right;">✅</td></tr><tr><td>setInterval</td><td style="text-align:center;">✅</td><td style="text-align:right;">✅</td></tr><tr><td>setImmediate</td><td style="text-align:center;">❌ (仅 IE10 支持)</td><td style="text-align:right;">✅</td></tr><tr><td>requestAnimationFrame</td><td style="text-align:center;">✅</td><td style="text-align:right;">❌</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>requestAnimationFrame 是一个很特殊的存在，它会在页面渲染前调用。 在每一次 event loop 的末尾，判断当前页面是否处于渲染时机(比如硬件限制，60hz 的屏幕每 16.66ms 渲染一次)，如果是就重新渲染。</p></div><h2 id="微任务-micro-task" tabindex="-1">微任务 micro task <a class="header-anchor" href="#微任务-micro-task" aria-hidden="true">#</a></h2><table><thead><tr><th>-</th><th style="text-align:center;">浏览器</th><th style="text-align:right;">Node</th></tr></thead><tbody><tr><td>process.nextTick</td><td style="text-align:center;">❌</td><td style="text-align:right;">✅</td></tr><tr><td>MutationObserver</td><td style="text-align:center;">✅</td><td style="text-align:right;">❌</td></tr><tr><td>Promise</td><td style="text-align:center;">✅</td><td style="text-align:right;">✅</td></tr></tbody></table><p>Promise本身是同步，then/catch的回调函数是异步的微任务</p><h2 id="执行流程" tabindex="-1">执行流程 <a class="header-anchor" href="#执行流程" aria-hidden="true">#</a></h2><div class="img-box"><img src="https://limy-1309594960.cos.ap-beijing.myqcloud.com/202209181703122-event_loop.png" class="medium-zoom-image"><br><img src="https://limy-1309594960.cos.ap-beijing.myqcloud.com/202209181756737-event_loop.gif" class="medium-zoom-image"></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><ol><li>js 遇到一个异步任务后不会等待其返回结果，而是将其挂起，继续执行执行栈中的同步任务<br></li><li>当异步返回结果后，不会立即执行，而是将结果添加到任务队列中<br></li><li>当主线程空闲（任务都执行完）时，会查看任务队列中是否有任务，如果有将其取出并放入到执行栈，然后执行其中的同步代码<br></li><li>如此往复，形成了一个环（事件循环）<br></li><li>事件循环不一定每轮都伴随着重渲染。<br></li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 可以理解为，每一轮事件循环执行一个宏任务，清空所有微任务</p></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-hidden="true">#</a></h2><li><a target="blank" href="https://juejin.cn/post/6844903764202094606">一次弄懂Event Loop（彻底解决此类面试问题）</a></li>',17),d=[l];function s(n,o,c,h,m,g){return e(),a("div",null,d)}const b=t(r,[["render",s]]);export{_ as __pageData,b as default};
